generator client {
  provider = "prisma-client-js"
  output   = "./client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                String             @id @default(cuid())
  email             String             @unique
  password          String
  role              Role               @default(USER)
  status            Status             @default(ACTIVE)
  balance           Float              @default(0)
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  chainTransactions ChainTransaction[]
  transactions      Transaction[]
  wallets           UserWallet[]
  withdrawals       Withdrawal[]
  balances          UserBalance[]
}

model Transaction {
  id        String   @id @default(cuid())
  userId    String
  amount    Float
  type      TxType
  status    TxStatus @default(PENDING)
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model ChainTransaction {
  id          String        @id @default(cuid())
  userId      String
  chain       String
  to          String
  amount      String
  txHash      String?       @unique
  status      ChainTxStatus @default(PENDING)
  createdAt   DateTime      @default(now())
  confirmedAt DateTime?
  blockNumber BigInt?
  direction   TxDirection   @default(OUTBOUND)
  user        User          @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([chain])
  @@index([status])
}

model LedgerEntry {
  id          String     @id @default(cuid())
  userId      String
  chain       String
  amount      String
  type        LedgerType
  referenceId String?
  createdAt   DateTime   @default(now())

  @@index([userId, chain])
}

model UserBalance {
  id      String @id @default(cuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  chain   String
  balance String

  @@unique([userId, chain])
}

model Withdrawal {
  id            String   @id @default(cuid())
  userId        String
  amount        Float
  walletAddress String?
  status        TxStatus @default(PENDING)
  createdAt     DateTime @default(now())
  user          User     @relation(fields: [userId], references: [id])
}

model SystemSetting {
  key   String @id
  value String
}

model UserWallet {
  id               String   @id @default(cuid())
  userId           String
  chain            String
  derivationIndex  Int
  address          String
  createdAt        DateTime @default(now())
  lastKnownBalance String   @default("0")
  user             User     @relation(fields: [userId], references: [id])

  @@unique([chain, derivationIndex])
  @@unique([userId, chain])
  @@index([userId])
  @@index([address])
}

model ChainScanState {
  chain            String   @id
  lastScannedBlock BigInt   @default(0)
  updatedAt        DateTime @default(now()) @updatedAt
}

enum TreasuryAccountType {
  ASSET
  LIABILITY
  EQUITY
}

enum TreasuryLedgerReferenceType {
  DEPOSIT
  WITHDRAWAL_REQUEST
  WITHDRAWAL_EXECUTED
  SWEEP
  TREASURY_MOVE
  ADJUSTMENT
}

enum WalletLifecycleStatus {
  GENERATED
  ACTIVE
  ROTATING
  ROTATED
  DISABLED
  SWEPT
  ARCHIVED
}

model WalletLifecycle {
  id                 String               @id @default(cuid())
  walletAddress      String
  network            String
  currency           String
  userId             String
  status             WalletLifecycleStatus
  sweptAt            DateTime?
  replacedByWalletId String?
  createdAt          DateTime             @default(now())

  replacedBy         WalletLifecycle?     @relation("ReplacedBy", fields: [replacedByWalletId], references: [id])
  replacements       WalletLifecycle[]    @relation("ReplacedBy")

  @@unique([walletAddress])
  @@index([userId])
  @@index([network, currency])
  @@index([status])
}

model TreasuryAccount {
  id              String               @id @default(cuid())
  name            String
  type            TreasuryAccountType
  network         String?
  currency        String
  walletAddress   String?
  parentAccountId String?
  isActive        Boolean              @default(true)
  createdAt       DateTime             @default(now())

  parentAccount   TreasuryAccount?     @relation("ParentAccount", fields: [parentAccountId], references: [id])
  children        TreasuryAccount[]    @relation("ParentAccount")
  entries         TreasuryEntry[]

  @@unique([walletAddress])
  @@unique([name, currency, network])
  @@index([type, network, currency])
  @@index([walletAddress])
  @@index([parentAccountId])
}

model TreasuryLedger {
  id            String                     @id @default(cuid())
  referenceType TreasuryLedgerReferenceType
  referenceId   String?
  description   String
  network       String
  currency      String
  createdByAdminId String?
  locked        Boolean                    @default(false)
  createdAt     DateTime                   @default(now())

  entries       TreasuryEntry[]

  @@index([referenceType])
  @@index([network, currency])
  @@index([createdAt])
}

model TreasuryEntry {
  id          String   @id @default(cuid())
  ledgerId    String
  accountId   String
  debitAmount BigInt   @default(0)
  creditAmount BigInt  @default(0)
  currency    String
  network     String
  createdAt   DateTime @default(now())

  ledger      TreasuryLedger @relation(fields: [ledgerId], references: [id])
  account     TreasuryAccount @relation(fields: [accountId], references: [id])

  @@index([ledgerId])
  @@index([accountId])
  @@index([network, currency])
  @@index([accountId, createdAt])
}

// balance snapshots support the integrity layer, tracking assets vs liabilities over time
model BalanceSnapshot {
  id              String   @id @default(cuid())
  snapshotTime    DateTime @default(now())
  network         String
  currency        String
  totalAssets     BigInt
  totalLiabilities BigInt
  totalEquity     BigInt

  @@index([network, currency])
  @@index([snapshotTime])
}

model TreasuryState {
  chain                String    @id
  totalOnchainBalance  String    @default("0")
  totalUserLiabilities String    @default("0")
  sweepableBalance     String    @default("0")
  lastSyncedAt         DateTime  @default(now())
  locked               Boolean   @default(false)
  lockedAt             DateTime?
  lockedBy             String?
}

model Sweep {
  id          String      @id @default(cuid())
  chain       String
  amount      String
  amountRaw   String
  fromWallet  String
  toWallet    String
  txHash      String?     @unique
  status      SweepStatus @default(PENDING)
  initiatedBy String
  error       String?
  createdAt   DateTime    @default(now())
  confirmedAt DateTime?

  @@index([chain])
  @@index([status])
  @@index([initiatedBy])
}

enum Role {
  USER
  ADMIN
}

enum Status {
  ACTIVE
  BANNED
}

enum TxType {
  DEPOSIT
  WITHDRAWAL
}

enum TxStatus {
  PENDING
  COMPLETED
  FAILED
  APPROVED
  REJECTED
}

enum ChainTxStatus {
  PENDING
  BROADCASTED
  CONFIRMED
  FAILED
}

enum TxDirection {
  INBOUND
  OUTBOUND
}

enum LedgerType {
  DEPOSIT
  WITHDRAWAL
  ADJUSTMENT
  TRANSFER
  EARNING
}

enum SweepStatus {
  PENDING
  BROADCASTING
  CONFIRMED
  FAILED
}

// ────────────────────────────────────────────────────────────────
// Treasury Global Integrity Models
// ────────────────────────────────────────────────────────────────

model Network {
  id          String   @id @default(cuid())
  name        String   @unique
  chainId     Int      @unique
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())

  wallets     Wallet[]
  reserves    ReserveEntry[]
  liabilities LiabilityEntry[]
  syncState   SyncState?

  @@index([isActive])
}

model Wallet {
  id        String   @id @default(cuid())
  networkId String
  address   String
  label     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())

  network   Network        @relation(fields: [networkId], references: [id])
  reserves  ReserveEntry[]

  @@unique([networkId, address])
  @@index([networkId])
  @@index([isActive])
}

model ReserveEntry {
  id            String   @id @default(cuid())
  walletId      String
  networkId     String
  assetSymbol   String
  rawBalance    BigInt
  decimals      Int
  lastUpdatedAt DateTime @default(now()) @updatedAt

  wallet        Wallet  @relation(fields: [walletId], references: [id], onDelete: Cascade)
  network       Network @relation(fields: [networkId], references: [id], onDelete: Cascade)

  @@unique([walletId, assetSymbol])
  @@index([networkId, assetSymbol])
  @@index([lastUpdatedAt])
}

model LiabilityEntry {
  id            String   @id @default(cuid())
  networkId     String
  assetSymbol   String
  rawAmount     BigInt
  decimals      Int
  createdAt     DateTime @default(now())

  network       Network @relation(fields: [networkId], references: [id], onDelete: Cascade)

  @@index([networkId, assetSymbol])
  @@index([createdAt])
}

model PriceCache {
  assetSymbol   String   @id
  priceUsd      Decimal  @db.Decimal(38, 18)
  lastUpdatedAt DateTime @default(now()) @updatedAt
  ttlSeconds    Int      @default(300)

  @@index([lastUpdatedAt])
}

model SyncState {
  id                String   @id @default(cuid())
  networkId         String   @unique
  lastSuccessfulSync DateTime?
  syncStatus        SyncStatus @default(UNKNOWN)
  errorMessage      String?
  createdAt         DateTime @default(now())

  network           Network  @relation(fields: [networkId], references: [id], onDelete: Cascade)

  @@index([syncStatus])
}

enum SyncStatus {
  OK
  ERROR
  STALE
  UNKNOWN
}
